<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Minesweeper</title>
    <style>
        :root {
            --cell-size: 30px;
            --border-color: #7B7B7B;
            --bg-color: #C0C0C0;
            --hover-color: #E0E0E0;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #F0F0F0;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 1200px;
            width: 100%;
        }
        
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: #E0E0E0;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 500px;
            padding: 10px;
            background-color: var(--bg-color);
            border: 3px solid var(--border-color);
            border-radius: 5px;
        }
        
        .mine-count, .timer {
            background-color: black;
            color: red;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 1.5rem;
            padding: 5px 10px;
            border-radius: 3px;
        }
        
        .reset-button {
            font-size: 1.5rem;
            cursor: pointer;
            background: none;
            border: none;
            padding: 5px;
            border-radius: 50%;
            transition: background-color 0.3s;
        }
        
        .reset-button:hover {
            background-color: var(--hover-color);
        }
        
        .board {
            display: grid;
            grid-template-columns: repeat(var(--cols, 10), var(--cell-size));
            grid-template-rows: repeat(var(--rows, 10), var(--cell-size));
            gap: 1px;
            background-color: var(--border-color);
            border: 3px solid var(--border-color);
            user-select: none;
        }
        
        .cell {
            width: var(--cell-size);
            height: var(--cell-size);
            background-color: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 16px;
            cursor: pointer;
            box-sizing: border-box;
            border: 2px outset white;
        }
        
        .cell:hover {
            background-color: var(--hover-color);
        }
        
        .cell.revealed {
            background-color: #D3D3D3;
            border: 1px solid #A9A9A9;
        }
        
        .cell.mine {
            background-color: red;
        }
        
        .cell.flagged::after {
            content: "ðŸš©";
        }
        
        .number-1 { color: blue; }
        .number-2 { color: green; }
        .number-3 { color: red; }
        .number-4 { color: darkblue; }
        .number-5 { color: darkred; }
        .number-6 { color: teal; }
        .number-7 { color: black; }
        .number-8 { color: gray; }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 10px;
        }
        
        .difficulty select, .room-controls input, .room-controls button {
            padding: 8px 12px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-size: 14px;
        }
        
        .room-controls button {
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        .room-controls button:hover {
            background-color: #45a049;
        }
        
        .room-info {
            margin-top: 10px;
            padding: 10px;
            background-color: #E0E0E0;
            border-radius: 5px;
            text-align: center;
        }
        
        .players-list {
            width: 100%;
            max-width: 500px;
            margin-top: 20px;
            background-color: white;
            border-radius: 5px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .players-list h3 {
            margin-top: 0;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        .player {
            padding: 5px;
            margin: 5px 0;
            border-radius: 3px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .player-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        
        .current-player {
            background-color: #F0F0F0;
            font-weight: bold;
        }
        
        .connection-status {
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 12px;
            display: inline-block;
            margin-left: 10px;
        }
        
        .connected {
            background-color: #DFF2BF;
            color: #4F8A10;
        }
        
        .disconnected {
            background-color: #FFD2D2;
            color: #D8000C;
        }
        
        .connecting {
            background-color: #FEEFB3;
            color: #9F6000;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            max-width: 500px;
            width: 90%;
            text-align: center;
        }
        
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        
        .modal-button {
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .primary-button {
            background-color: #4CAF50;
            color: white;
            border: none;
        }
        
        .secondary-button {
            background-color: #f44336;
            color: white;
            border: none;
        }

        #invite-modal-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        #invite-link {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            margin-bottom: 10px;
            font-size: 14px;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Multiplayer Minesweeper</h1>
            <div id="connection-status" class="connection-status disconnected">Disconnected</div>
        </div>
        
        <div class="controls">
            <div class="difficulty">
                <label for="difficulty">Difficulty:</label>
                <select id="difficulty">
                    <option value="beginner">Beginner (9x9, 10 mines)</option>
                    <option value="intermediate" selected>Intermediate (16x16, 40 mines)</option>
                    <option value="expert">Expert (16x30, 99 mines)</option>
                </select>
            </div>
            
            <div class="room-controls">
                <input type="text" id="room-id" placeholder="Room ID">
                <button id="create-room">Create Room</button>
                <button id="join-room">Join Room</button>
                <button id="invite-players">Invite Players</button>
            </div>
        </div>
        
        <div id="room-info" class="room-info" style="display: none;">
            <p>Room ID: <span id="current-room-id"></span></p>
        </div>
        
        <div class="game-container">
            <div class="status-bar">
                <div class="mine-count">000</div>
                <button class="reset-button">ðŸ˜Š</button>
                <div class="timer">000</div>
            </div>
            
            <div class="board" id="minesweeper-board"></div>
        </div>
        
        <div class="players-list" id="players-list" style="display: none;">
            <h3>Players in Room</h3>
            <div id="players-container"></div>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal">
        <div class="modal-content">
            <h2 id="game-result">Game Over</h2>
            <p id="game-message"></p>
            <div class="modal-buttons">
                <button id="new-game-button" class="modal-button primary-button">New Game</button>
            </div>
        </div>
    </div>
    
    <!-- Invite Modal -->
    <div id="invite-modal" class="modal">
        <div class="modal-content">
            <h2>Invite Players</h2>
            <div id="invite-modal-content">
                <p>Share this link with friends to invite them to your game:</p>
                <input type="text" id="invite-link" readonly>
                <button id="copy-link" class="modal-button primary-button">Copy Link</button>
            </div>
            <div class="modal-buttons">
                <button id="close-invite-modal" class="modal-button secondary-button">Close</button>
            </div>
        </div>
    </div>
    
    <!-- Entry Modal -->
    <div id="entry-modal" class="modal" style="display: flex;">
        <div class="modal-content">
            <h2>Welcome to Multiplayer Minesweeper</h2>
            <p>Enter your name to continue:</p>
            <input type="text" id="player-name" placeholder="Your Name" style="width: 100%; padding: 10px; margin: 10px 0; border-radius: 5px; border: 1px solid #ccc;">
            <div class="modal-buttons">
                <button id="continue-button" class="modal-button primary-button">Continue</button>
            </div>
        </div>
    </div>

    <!-- PeerJS library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    
    <script>
        // Global variables
        let boardState = [];
        let mineLocations = [];
        let revealedCount = 0;
        let gameStarted = false;
        let gameOver = false;
        let mineCount = 40;
        let remainingMines = mineCount;
        let rows = 16;
        let cols = 16;
        let timerInterval;
        let timerValue = 0;
        let playerName = '';
        let playerId = '';
        let roomId = '';
        let isRoomCreator = false;
        let peers = {};
        let players = {};
        let myColor = getRandomColor();
        let peer = null;
        let lastClickedCell = null;
        
        // DOM elements
        const board = document.getElementById('minesweeper-board');
        const mineCountDisplay = document.querySelector('.mine-count');
        const timerDisplay = document.querySelector('.timer');
        const resetButton = document.querySelector('.reset-button');
        const difficultySelect = document.getElementById('difficulty');
        const roomIdInput = document.getElementById('room-id');
        const createRoomButton = document.getElementById('create-room');
        const joinRoomButton = document.getElementById('join-room');
        const invitePlayersButton = document.getElementById('invite-players');
        const roomInfo = document.getElementById('room-info');
        const currentRoomIdSpan = document.getElementById('current-room-id');
        const playersList = document.getElementById('players-list');
        const playersContainer = document.getElementById('players-container');
        const gameOverModal = document.getElementById('game-over-modal');
        const gameResultTitle = document.getElementById('game-result');
        const gameMessage = document.getElementById('game-message');
        const newGameButton = document.getElementById('new-game-button');
        const inviteModal = document.getElementById('invite-modal');
        const inviteLink = document.getElementById('invite-link');
        const copyLinkButton = document.getElementById('copy-link');
        const closeInviteModalButton = document.getElementById('close-invite-modal');
        const entryModal = document.getElementById('entry-modal');
        const playerNameInput = document.getElementById('player-name');
        const continueButton = document.getElementById('continue-button');
        const connectionStatus = document.getElementById('connection-status');
        
        // Initialize PeerJS connection
        function initializePeer() {
            peer = new Peer(null, {
                debug: 2
            });
            
            peer.on('open', (id) => {
                playerId = id;
                updateConnectionStatus('connected');
                console.log('My peer ID is: ' + id);
            });
            
            peer.on('connection', (conn) => {
                handleConnection(conn);
            });
            
            peer.on('error', (err) => {
                console.error('PeerJS error:', err);
                updateConnectionStatus('disconnected');
            });
            
            peer.on('disconnected', () => {
                updateConnectionStatus('disconnected');
                console.log('Peer disconnected');
                peer.reconnect();
            });
        }
        
        // Handle new peer connection
        function handleConnection(conn) {
            conn.on('open', () => {
                console.log('Connected to: ' + conn.peer);
                peers[conn.peer] = conn;
                
                // Send current game state if you're the room creator
                if (isRoomCreator) {
                    sendGameState(conn);
                }
                
                // Exchange player info
                conn.send({
                    type: 'player_info',
                    name: playerName,
                    color: myColor,
                    id: playerId
                });
            });
            
            conn.on('data', (data) => {
                handlePeerMessage(conn.peer, data);
            });
            
            conn.on('close', () => {
                console.log('Connection closed with: ' + conn.peer);
                delete peers[conn.peer];
                delete players[conn.peer];
                updatePlayersList();
            });
            
            conn.on('error', (err) => {
                console.error('Connection error:', err);
            });
        }
        
        // Send message to all connected peers
        function broadcastToPeers(message) {
            Object.values(peers).forEach(conn => {
                conn.send(message);
            });
        }
        
        // Handle messages from peers
        function handlePeerMessage(peerId, data) {
            console.log('Received message:', data);
            
            switch (data.type) {
                case 'cell_click':
                    handleRemoteCellClick(data.row, data.col, data.isRightClick);
                    break;
                    
                case 'game_state':
                    if (!isRoomCreator) {
                        applyGameState(data);
                    }
                    break;
                    
                case 'new_game':
                    if (!isRoomCreator) {
                        rows = data.rows;
                        cols = data.cols;
                        mineCount = data.mineCount;
                        initializeGame();
                    }
                    break;
                    
                case 'player_info':
                    players[peerId] = {
                        name: data.name,
                        color: data.color,
                        id: data.id
                    };
                    updatePlayersList();
                    break;
                    
                case 'cursor_position':
                    updateRemoteCursor(peerId, data.row, data.col);
                    break;
            }
        }
        
        // Send complete game state to a peer
        function sendGameState(conn) {
            conn.send({
                type: 'game_state',
                boardState: boardState,
                mineLocations: mineLocations,
                rows: rows,
                cols: cols,
                mineCount: mineCount,
                remainingMines: remainingMines,
                gameStarted: gameStarted,
                gameOver: gameOver,
                timerValue: timerValue
            });
        }
        
        // Apply received game state
        function applyGameState(state) {
            rows = state.rows;
            cols = state.cols;
            mineCount = state.mineCount;
            remainingMines = state.remainingMines;
            gameStarted = state.gameStarted;
            gameOver = state.gameOver;
            timerValue = state.timerValue;
            
            // Stop current timer if running
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Start timer if game is in progress
            if (gameStarted && !gameOver) {
                startTimer();
            }
            
            // Update displays
            updateMineCount();
            updateTimerDisplay();
            
            // Create board with received state
            createBoard();
            
            // Copy mine locations and board state
            mineLocations = [...state.mineLocations];
            
            // Apply board state (reveal cells, flags, etc.)
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cellState = state.boardState[r][c];
                    const cellElement = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                    
                    if (cellState.isRevealed) {
                        revealCell(cellElement, r, c, false);
                    }
                    
                    if (cellState.isFlagged) {
                        cellElement.classList.add('flagged');
                    }
                }
            }
            
            if (gameOver) {
                // Update reset button to show game over state
                resetButton.textContent = 'ðŸ˜µ';
            }
        }
        
        // Initialize the game
        function initializeGame() {
            // Reset game state
            gameStarted = false;
            gameOver = false;
            revealedCount = 0;
            resetButton.textContent = 'ðŸ˜Š';
            
            // Stop timer if running
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            
            // Reset timer display
            timerValue = 0;
            updateTimerDisplay();
            
            // Reset remaining mines
            remainingMines = mineCount;
            updateMineCount();
            
            // Create the board
            createBoard();
            
            // Initialize mines (will be placed on first click)
            mineLocations = [];
            
            // If room creator, broadcast new game to all peers
            if (isRoomCreator) {
                broadcastToPeers({
                    type: 'new_game',
                    rows: rows,
                    cols: cols,
                    mineCount: mineCount
                });
            }
        }
        
        // Create the game board
        function createBoard() {
            // Clear the board
            board.innerHTML = '';
            
            // Set CSS variables for board size
            board.style.setProperty('--rows', rows);
            board.style.setProperty('--cols', cols);
            
            // Initialize board state
            boardState = Array(rows).fill().map(() => 
                Array(cols).fill().map(() => ({
                    isMine: false,
                    isRevealed: false,
                    isFlagged: false,
                    adjacentMines: 0
                }))
            );
            
            // Create cells
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    // Add event listeners
                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('contextmenu', handleRightClick);
                    cell.addEventListener('mouseover', handleCellHover);
                    
                    board.appendChild(cell);
                }
            }
        }
        
        // Place mines randomly, avoiding the first clicked cell and its neighbors
        function placeMines(firstRow, firstCol) {
            // Mark positions to avoid (first click and neighbors)
            const avoid = [];
            for (let r = Math.max(0, firstRow - 1); r <= Math.min(rows - 1, firstRow + 1); r++) {
                for (let c = Math.max(0, firstCol - 1); c <= Math.min(cols - 1, firstCol + 1); c++) {
                    avoid.push(`${r},${c}`);
                }
            }
            
            // Place mines
            let minesPlaced = 0;
            while (minesPlaced < mineCount) {
                const row = Math.floor(Math.random() * rows);
                const col = Math.floor(Math.random() * cols);
                const key = `${row},${col}`;
                
                if (!avoid.includes(key) && !mineLocations.some(m => m.row === row && m.col === col)) {
                    mineLocations.push({ row, col });
                    boardState[row][col].isMine = true;
                    minesPlaced++;
                }
            }
            
            // Calculate adjacent mines for each cell
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    if (!boardState[r][c].isMine) {
                        boardState[r][c].adjacentMines = countAdjacentMines(r, c);
                    }
                }
            }
        }
        
        // Count adjacent mines for a cell
        function countAdjacentMines(row, col) {
            let count = 0;
            for (let r = Math.max(0, row - 1); r <= Math.min(rows - 1, row + 1); r++) {
                for (let c = Math.max(0, col - 1); c <= Math.min(cols - 1, col + 1); c++) {
                    if (r === row && c === col) continue;
                    if (boardState[r][c].isMine) count++;
                }
            }
            return count;
        }
        
        // Handle cell click
        function handleCellClick(event) {
            if (gameOver) return;
            
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            // Send click to peers
            broadcastToPeers({
                type: 'cell_click',
                row: row,
                col: col,
                isRightClick: false
            });
            
            // Process click
            processCellClick(row, col, false);
        }
        
        // Handle right click (flag placement)
        function handleRightClick(event) {
            event.preventDefault();
            if (gameOver) return;
            
            const cell = event.target;
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            // Send right click to peers
            broadcastToPeers({
                type: 'cell_click',
                row: row,
                col: col,
                isRightClick: true
            });
            
            // Process right click
            processCellClick(row, col, true);
        }
        
        // Handle cell hover for cursor position sharing
        function handleCellHover(event) {
            const cell = event.target;
            
            // Highlight last hovered cell for all users
            if (lastClickedCell && lastClickedCell !== cell) {
                lastClickedCell.style.border = "2px outset white";
            }
            
            cell.style.border = "2px solid #FFA500";
            lastClickedCell = cell;
            
            // Share cursor position
            const row = parseInt(cell.dataset.row);
            const col = parseInt(cell.dataset.col);
            
            broadcastToPeers({
                type: 'cursor_position',
                row: row,
                col: col
            });
        }
        
        // Update remote player's cursor position
        function updateRemoteCursor(peerId, row, col) {
            // Remove previous cursor highlight for this peer
            const prevCursor = document.querySelector(`.remote-cursor-${peerId}`);
            if (prevCursor) {
                prevCursor.classList.remove(`remote-cursor-${peerId}`);
            }
            
            // Add highlight to the cell
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            if (cell) {
                cell.classList.add(`remote-cursor-${peerId}`);
                
                // Apply player color as border
                if (players[peerId]) {
                    cell.style.outline = `2px solid ${players[peerId].color}`;
                    cell.style.outlineOffset = "-2px";
                }
                
                // Remove highlight after a delay
                setTimeout(() => {
                    cell.style.outline = "";
                    cell.classList.remove(`remote-cursor-${peerId}`);
                }, 1000);
            }
        }
        
        // Process cell click (both local and remote)
        function processCellClick(row, col, isRightClick) {
            const cell = document.querySelector(`.cell[data-row="${row}"][data-col="${col}"]`);
            
            // Start game on first click
            if (!gameStarted) {
                // Only start game once (by room creator)
                if (isRoomCreator) {
                    startGame(row, col);
                }
                
                // Don't process right-clicks if game hasn't started
                if (isRightClick) return;
            }
            
            if (isRightClick) {
                // Toggle flag
                if (!boardState[row][col].isRevealed) {
                    toggleFlag(cell, row, col);
                }
            } else {
                // Reveal cell
                if (!boardState[row][col].isFlagged) {
                    revealCell(cell, row, col, true);
                }
            }
        }
        
        // Handle click from remote peer
        function handleRemoteCellClick(row, col, isRightClick) {
            processCellClick(row, col, isRightClick);
        }
        
        // Toggle flag on/off for a cell
        function toggleFlag(cell, row, col) {
            if (boardState[row][col].isFlagged) {
                // Remove flag
                cell.classList.remove('flagged');
                boardState[row][col].isFlagged = false;
                remainingMines++;
            } else {
                // Add flag
                cell.classList.add('flagged');
                boardState[row][col].isFlagged = true;
                remainingMines--;
            }
            
            // Update mine count display
            updateMineCount();
        }
        
        // Reveal a cell
        function revealCell(cell, row, col, checkWin) {
            if (boardState[row][col].isRevealed) return;
            
            // Mark as revealed
            boardState[row][col].isRevealed = true;
            cell.classList.add('revealed');
            
            // Remove any flag
            if (boardState[row][col].isFlagged) {
                cell.classList.remove('flagged');
                boardState[row][col].isFlagged = false;
                remainingMines++;
                updateMineCount();
            }
            
            // Check if mine
            if (boardState[row][col].isMine) {
                cell.classList.add('mine');
                cell.textContent = 'ðŸ’£';
                gameOver = true;
                endGame(false);
                return;
            }
            
            // Count of non-mine cells revealed
            revealedCount++;
            
            // Check adjacent mines
            const adjacentMines = boardState[row][col].adjacentMines;
            if (adjacentMines > 0) {
                cell.textContent = adjacentMines;
                cell.classList.add(`number-${adjacentMines}`);
            } else {
                // Auto-reveal neighbors for cells with no adjacent mines
                for (let r = Math.max(0, row - 1); r <= Math.min(rows - 1, row + 1); r++) {
                    for (let c = Math.max(0, col - 1); c <= Math.min(cols - 1, col + 1); c++) {
                        if (r === row && c === col) continue;
                        if (!boardState[r][c].isRevealed && !boardState[r][c].isFlagged) {
                            const neighborCell = document.querySelector(`.cell[data-row="${r}"][data-col="${c}"]`);
                            revealCell(neighborCell, r, c, false);
                        }
